이것이 자바다
============   
  ## 프로그래밍 언어?
  - 사람과 컴퓨터가 대화하기 위해 필요한 언어(중간다리 역할)   
  - 고급언어?
    * 프로그래밍 언어 중 사람이 쉽게 이해할 수 있는 언어   
    * 컴파일(compile)과 정 필요(컴퓨터가 이해할 수 있도록 기계어로 변환)
    * 예) C, C++, Java
  - 저급언어
    * 기계어에 가까운 언어(배우기 까다로움)
    * 예) 어셈블리어 

  - 프로그램?
    * 컴퓨터에서 특정 목적을 수행하기 위해 프로그래밍 언어로 작성된 소스를 기계어로 변역한 것
      * 소스(Source) : 프로그래밍 언어들로 작성된 내용

  ## 자바
  - 자바의 특징
    * 이식성이 높다.
      + 이식성? 서로 다른 실행 환경을 가진 **시스템 간 프로그램을 옮겨 실행** 할 수 있는 것
      + 예) 윈도우 환경에서 실행되는 프로그램이 리눅스에서 실행 가능 -> 이식성이 높다.
      + **JRE(java Runtime Environment)** 자바 실행 환경이 설치되어있는 모든 운영체제에서 실행 가능
    * 객체 지향 언어
      + 객체 지향 프로그래밍(OOP : Object Oriented Programming)
        : 프로그램 개발 기법, 부품에 해당하는 **객체를 먼저 만듦** -> 객체들을 하나씩 **조립 및 연결** -> 전체 프로그램 **완성**
      + 객체를 만들기 위해 설계도(클래스) 작성, 객체를 연결하여 프로그램을 만들어 냄 -> 캡슐화, 상속, 다형성을 완벽히 지원함
    * 함수적 스타일 코딩 지원
      + 람다식(Lambda Expressions) : Java 8부터 지원 / 컬렉션의 요소를 필터링, 매핑, 집계 처리하는데 쉬워지고, 코드 간결
    * 메모리 자동 관리
      + C++ : 메모리에 생성된 객체를 제거 -> 코드 작성필요 (이러한 작업이 지속적으로 이루어지지 않으면 프로그램 다운 될 수도..)
      + 자바 : 개발자가 직접 메모리에 접근 불가( **자바가 직접 관리** ) 
        예) 객체 생성 -> 자동적으로 메모리 영역 할당, 사용 하지 않을 경우 Garbage Collector 실행하여 객체 제거
    * 다양한 애플리케이션 개발 가능
      + 다양한 운영체제에서 사용할 수 있는 개발 도구와 API를 묶어 Edition 형태로 정의
      + Java SE(Standard Edition) - 기본 에디션 : JVM + 도구, 라이브러리 API를 정의   
        JDK(Java Development Kit) : 자바 개발 키트, Java SE 구현체, 자바 프로그램을 개발하고 실행하기 위해 필요!
      + Java EE(Enterprise Edition) - 서버용 애플리케이션 개발 에디션 : 서버용 애플리케이션을 개발하기 위한 도구, 라이브러리 API 정의
    * 멀티 스레드(Multi-Thread)를 쉽게 구현 가능
      + 스레드 생성 및 제어와 관련된 라이브러리 API 제공
    * 동적 로딩(Dynamic Loading) 지원
      + 객체가 필요한 시점에 클래스를 동적 로딩해서 객체 생성 -> 유지보수를 쉽고 빠르게 진행 가능
    * 오픈 소스 라이브러리 풍부   
    
  ## 자바 가상 기계(JVM)
   - 자바 프로그램을 이루고 있는 바이트 코드를 해석하고 실행할 수 있는 가상의 운영체제
    * 바이트 코드는 모든 JVM에서 동일한 실행 결과 보장, but JVM은 운영체제에 종속적(운영체제에 맞는 JVM 설치 필요)   
       
   <p align="center"> <img src="/img/Java/javaExecution.png" width="50%" height="40%" title="자바실행단계사진"> </img> </p>   
       
   1. .java 파일(소스파일) 작성    
   2. 컴파일러(javac.exe)로 컴파일
   3. .class 파일(바이트 코드 파일) 생성
   4. JVM 구동 명령어(java.exe)에 의해 해석, 운영체제에 맞는 기계어로 번역   
     
 ## 변수
  - 한가지 타입의 하나의 값을 저장할 수 있는 메모리 공간  
  
  - 변수 선언
    ```
    * 데이터 타입 변수이름; -> Ex) int age;
    * 한번에 선언 가능 -> Ex) int x, y, z
  - 변수 이름은 메모리 주소에 붙여진 이름, 따라서 자바에서 정한 **명명 규칙**을 따라야함
    ```
    * 첫 번째 글자는 문자이거나 '_', '$', 이어야 하고 숫자로 시작할 수 없다. [필수]
    * 영어 대소문자를 구분한다. [필수]
    * 자바의 예약어를 변수명으로 사용할 수 없다. [필수]
    * 첫 문자는 영어 소문자로 시작하되, 다른 단어가 붙을 경우 첫 문자를 대문자로 한다. [관례] Ex) maxSpeed
    * 스코프 내에 중복된 이름을 사용할 수 없다.
    * 변수명에 한글을 사용할 수 있으나 호환성 등의 문제로 영문 사용을 권장한다.
  - 변수 사용
    * 변수값 저장
      ```
      * 값을 저장시 대입 연산자(=) 사용
      int score; // 변수 선언
      score = 90; // 값 저장 
      -> 변수를 선언하고 처음 값을 저장한 경우, 해당 값[여기서는 90]을 초기값
         변수에 초기값을 주는 행위 -> **변수의 초기화**
          
      * 변수 선언과 동시에 초기값을 줄 수 있음
      int score = 90;
    * 변수 초기화
      ```
      클래스 멤버변수 : 초기화 자동 [0, 0.0, false, ...]
      메소드 변수 : 초기화 지정 필요!
      public class Test {
        static int a;
        public static void main(String[] args) {
          int b; //경고뜸
          int c = a + b; 
        }
      }
    * 리터럴
      ```
      소스코드 내에서 직접 입력된 값 -> 변수 초기화에 쓰인 값이라고 봐도 무방
      상수와 같은 의미지만, 프로그램에서 상수는 "값을 한 번 저장하면 변경 할 수 없는 변수"로 정의하기에 리터럴을 사용
      Ex) long a = 1L; // 1L 이 리터럴  
      
      종류  
        - 정수 리터럴(0[10진수], 02[8진수], 0xA[16진수]) -> 저장가능 타입 : byte, char, short, int, long  
        - 실수 리터럴(0.25[10진수 실수], 5E3[10진수 지수와가수, 5*10^3]) -> 저장가능 타입 : float, double
        - 문자 리터럴('한'[작은 따옴표로 묶은 텍스트], '\n') -> 저장가능 타입 : char
        - 문자열 리터럴("대한민국"[큰 따옴표로 묶은 텍스트], 이스케이프 문자 사용가능) ->  저장가능 타입 : string
        - 논리 리터럴(true, false) -> 저장가능 타입 : boolean
    * 변수값 읽기
      ```
      초기화 되지 않은 변수는 읽을 수 없음!
  - 변수 사용 범위
    ```
    중괄호 {}블록 내에서 선언되고 사용 -> 선언된 블록 내에서만 사용가능 -> 즉, 변수 선언시 "사용될 범위와 선언 위치 결정" 필요!
    * 참고 : 메소드 블록 내에서 선언된 변수 -> 로컬 변수(local variable) : 메소드 실행이 끝나면 메모리에서 자동으로 없어짐.  
 ## 데이터 타입
  - 기본(원시) 타입(primeitive type)
    <table>
      <tr>
        <td>값의 종류</td>
        <td>기본 타입</td>
        <td colspan="2">메모리 사용 크기</td>
        <td>기본값</td>
        <td>부호</td>
        <td>범위</td>
        <td>기타</td>
      </tr>
      <tr>
        <td rowspan="5">정수</td>
        <td>byte</td>
        <td>1 byte</td>
        <td>8 bit</td>
        <td>0</td>
        <td>+,-</td>
        <td>-2^7~(2^7-1)<br>[-128~127]</td>
        <td>색상정보, 파일 또는 이미지 등의 <br>이진(바이너리) 데이터 처리시 사용</td>
      </tr>
      <tr>
        <td>char</td>
        <td>2 byte</td>
        <td>16 bit</td>
        <td>\u0000</td>
        <td>없음</td>
        <td>0 ~ 2^16-1<br>(유니코드 : \u0000~\uFFFF, 0~65,535)</td>
        <td>자바는 모든 문자를 유니코드로 처리,<br> 유니코드는 음수 X</td>
      </tr>
      <tr>
        <td>short</td>
        <td>2 byte</td>
        <td>16 bit</td>
        <td>0</td>
        <td>+,-</td>
        <td>-2^15~(2^15-1)<br>-32,768~32,767</td>
        <td>C 언어와의 호환을 위해 사용,<br> 자바에선 비교적 잘 사용하지 않음</td>
      </tr>
      <tr>
        <td>int</td>
        <td>4 byte</td>
        <td>32 bit</td>
        <td>0</td>
        <td>+,-</td>
        <td>-2^31~(2^31-1)<br>-2,147,483,648 ~<br>2,147,483,647</td>
        <td>일반적으로 정수 저장시 사용<br>직접 코드에서 입력시 8, 10, 16진수로 표현 가능,<br>숫자앞 '0'(8진수), '0x'(16진수),<br>값이 2진수로 변환되어 저장 </td>
      </tr>
      <tr>
        <td>long</td>
        <td>8 byte</td>
        <td>64 bit</td>
        <td>0L</td>
        <td>+,-</td>
        <td>-2^63~(2^63-1)<br>-9,223,372,036,854,775,808 ~ <br>9,223,372,036,854,775,807</td>
        <td>수치가 큰 데이터를 다루는 프로그램(은행 및 우주 관련)</td>
      </tr>
      <tr>
        <td rowspan="2">실수</td>
        <td>float</td>
        <td>4 byte</td>
        <td>32 bit</td>
        <td>0.0F</td>
        <td>+,-</td>
        <td>±1.4X10^-45 ~ <br>±3.4028235X10^38</td>
        <td rowspan="2">실수타입 -> 소수점이 있는 실수 데이터를 저장 가능<br>부동 소수점 방식 : ± m X r^e<br>(± : 부호 m : 가수 r : 밑수 e : 지수 )</td>
      </tr>
      <tr>
        <td>double</td>
        <td>8 byte</td>
        <td>64 bit</td>
        <td>0.0 or 0.0d/td>
        <td>+,-</td>
        <td>±4.9X10^-324 ~ <br>±1.7976931348623157X10^308</td>
      </tr>
       <tr>
        <td>논리</td>
        <td>boolean</td>
        <td>1 byte</td>
        <td>8 bit</td>
        <td>false</td>
        <td>없음</td>
        <td>true, false</td>
        <td>두 가지 상태값을 저장할 필요성이 있을 시, <br>조건문, 제어문의 실행 흐름 변경시 주로 사용</td> 
      </tr>
    </table>
  # Reference   
   - 신용권, 이것이 자바다, 한빛미디어(2019)   
   
  ## String str = new String(" ") / String str = " " 차이   
   - String
     * new String() 이용 
        ```
        - String str = new String("str");
        - Heap area에 할당    
        - 같은 문자열이라도 다른 객체이기때문에 선언한 만큼 새로운 객체가 메모리에 올라감       
     * 리터럴 이용
        ```
        - String str = "str";
        - String constant pool(상수 영역)에 할당
        - 내부적으로 String의 intern() 메소드 호출, 주어진 문자열이 String constant pool에 존재하는지 검색,    
          존재할 경우 해당 주소값을 할당 받아 반환, 없을 경우 String constant pool에 생성하고 새로운 주소값 반환   
          -> 즉, 메모리에는 하나만 올라감
   - 결론
     * 같은 값을 갖더라도 메모리 상에서 처리되는 방식이 다름
   - 참고
     * String constant pool은 Heap area에 포함된 공간!
     * String class의 .intern() 메소드를 사용시 heap area에 할당된 값을 String constant pool에 등록 가능
     * 사진
       <p align="center"><img src="/img/Java/String_differ_newString.png" width="60%" height="40%" title="String str = new String(" ") / String str = " " 차이"> </img> </p> 
   - Reference   
     * https://www.journaldev.com/797/what-is-java-string-pool
     * https://qssdev.tistory.com/38
     * https://tomining.tistory.com/195
     
  ## java static   
   - non-static / static 
      <table>
        <tr>
          <td></td>
          <th> non-static </th>
          <th> static </th>
        </tr>
        <tr>
          <th>공간적 특성</th>
          <td>멤버는 객체마다 별도로 존재<br> = 인스턴스 멤버</td>
          <td>멤버는 클래스당 하나가 생성됨<br> = 클래스 멤버</td>
        </tr>
        <tr>
          <th>시간적 특성</th>
          <td>객체 생성 시 멤버 생성<br> - 객체가 생길 때 멤버도 생성<br> - 객체 생성 후 멤버 사용가능<br> - 객체가 사라지면 멤버도 생성</td>
          <td>클래스 로딩 시 멤버 생성<br> - 객체 생성 전에 이미 생성<br> - 객체 생성 전 멤버 사용가능<br>   => 객체 생성하지 않고 사용 가능<br> - 멤버는 프로그램이 종료시 사라짐</td>
        </tr>
        <tr>
          <th>공유의 특성</th>
          <td>공유 X<br> - 멤버는 객체 내 각각의 공간 유지<br> - 각기 다른 값 유지</td>
          <td>동일한 클래스의 모든 객체들이 하나의 저장공간 공유 O<br> - 항상 공통된 값 유지</td>
        </tr>
        <tr>
          <th>선언</th>
          <td colspan="2">
            class Card {<br>
              &nbsp; &nbsp; String kind; // 카드의 무늬 - 인스턴스 변수<br>
              &nbsp; &nbsp; int number;  // 카드의 숫자 - 인스턴스 변수<br>
              &nbsp; &nbsp; static int width = 100;  // 카드의 폭 - 클래스 변수<br>
              &nbsp; &nbsp; static int height = 250; // 카드의 높이 - 클래스 변수<br>
            }
          </td>
        </tr>
      <table>
   - 정리
     ```
     * 클래스 설계시, 멤버변수 중 모든 인스턴스에 공통적으로 사용해야 하는 것에 static을 사용
       - 인스턴스 생성시 각 인스턴스들은 서로 독립적이기 때문에 서로 다른 값을 유지
       - 경우에 따라서는 각 인스턴스들이 공통적으로 같은 값이 유지되어야하는 경우 static 사용   
        
     * 클래스 변수는 인스턴스를 생성하지 않아도 사용 가능
       - 클래스가 메모리에 올라갈때 이미 자동적으로 생성이 되기에 사용가능   
       
     * 클래스 메서드에서는 인스턴스 변수를 사용할 수 없음
       - 클래스 메서드는 인스턴스 생성 없이 호출 가능하지만, 인스턴스 변수는 인스턴스를 생성해야만 존재
         따라서, 클래스 메소드 호출시 인스턴스가 생성 되어있을 수도 있고 아닐 수도 있기 때문에 
         클래스 메서드에서 인스턴스 변수 사용을 허용 X
       - 하지만, 인스턴스 변수나 메서드에서는 클래스 멤버를 사용하는 것은 언제나 가능
         왜? 인스턴스 변수가 존재하는 경우는 클래스 멤버가 이미 메모리에 존재한다는 것을 의미하기 때문에
         
     * 메서드 내에서 인스턴스 변수를 사용하지 않는다면, 가능하면 static 붙이는 것을 고려
        - 메서드 호출시간이 짧아지기 때문에 효율 증가
        - 인스턴스 메서드는 실행시 호출되어야할 메서드를 찾는 과정이 추가적으로 필요하기 때문에 시간이 더 걸림
        
     * 클래스 설계시 static의 사용지침
        - 먼저 클래스의 멤버변수 중 모든 인스턴스에 공통된 값을 유지해야하는 것이 있는지 확인후 있을 경우 static 사용
        - 작성한 메서드 중 인스턴스 변수를 사용하지 않는 메서드에 대해서 static 사용 고려
        
      * 일반 적으로 
        - 인스턴스 변수와 관련된 작업을 하는 메서드 => 인스턴스 메서드(static 안붙은 메서드)
        - 클래스 변수(static [타입] [변수명])와 관련된 작업을 하는 메서드 => 클래스 메서드(static [리턴타입] [메서드명])
  - Reference   
     * https://gmlwjd9405.github.io/2018/08/04/java-static.html
     * https://vaert.tistory.com/101
     * https://wikidocs.net/228
    
