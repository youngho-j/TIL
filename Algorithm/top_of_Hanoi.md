# 하노이의 탑 
  - 1883년 프랑스 수학자 에두아르 뤼카가 소개한 문제
    <p align="center"><img src="/img/Algorithm/Tower_of_Hanoi.jpeg" width="50%" height="60%" title="하노이탑"></img></p>
  - 재귀 호출을 이용하여 풀 수 있는 가장 유명한 예제 중 하나
  - 아래 두 가지 조건을 만족시키면서, 한 기둥에 꽂힌 원판들을 그 순서 그대로 다른 기둥으로 옮겨서 다시 쌓는 것
    1. 한 번에 하나의 원판만 옮길 수 있으며, 막대에서 막대로만 움직일 수 있다.
    2. 큰 원판이 작은 원판 위에 있어서는 안 된다.
    
  - 이동 횟수 구하기(일반항)
    <p align="center"><img src="/img/Algorithm/hanoi_find_rule.png" width="100%" height="100%" title="하노이탑 규칙 찾기"></img></p>    
    
    위의 그림을 보면 3단계의 과정을 볼 수 있음(여기서 x는 n과 같음)    
    
    ```
    1단계 → 가장 큰 원판을 옮기기 위해 첫번째 막대에 있는 n-1개의 원판을 두번째 막대로 이동
            즉, 첫번째에서 두번째 막대로 가는 것을 a라고 하면, n-1번 만큼 반복 한다 = aₓ₋₁
    2단계 → 첫번째 막대에 남아 있는 가장 큰 원판을 세번째 막대로 이동
            = +1
    2단계 → 두번째 막대에 있는 n-1개의 원판을 세번째 막대로 이동
            = aₓ₋₁
    ```
    이 과정을 하나의 식으로 나타내면 (여기서 x는 n과 같음)
    |     |1단계|2단계|3단계|
    |:---:|:---:|:---:|:---:|
    |aₓ = |aₓ₋₁|1|aₓ₋₁|
    
    위와 같은 식이 되고, 아래와 같이 나타 낼 수 있음    
    `aₓ = aₓ₋₁ + 1 + aₓ₋₁`    
    조금 더 간편하게 식을 다듬을 경우 좌변과 우변에 +1을 더한 뒤 우변을 2로 묶어 아래와 같은 식 완성    
    `→ aₓ + 1 = 2(aₓ₋₁ + 1)`
    
    일반항을 구하기 위해 위 점화식을 풀어 본다면(여기서 x는 n과 같음)
    1. x 자리에 x, x-1 ~ 2를 대입 
     ~~~
     aₓ + 1 = 2(aₓ₋₁ + 1),
     aₓ₋₁ + 1 = 2(aₓ₋₂ + 1),
     aₓ₋₂ + 1 = 2(aₓ₋₃ + 1),
     ...,
     a₂ + 1 = 2(a₁ + 1)
     ~~~
    2. 각 변끼리 곱함    
    `(aₓ + 1)(aₓ₋₁ + 1)(aₓ₋₂ + 1)...(a₂ + 1) = 2(aₓ₋₁ + 1)2(aₓ₋₂ + 1)2(aₓ₋₃ + 1)...2(a₁ + 1)`
    3. 곱한 내용 정리    
    `(aₓ + 1)(aₓ₋₁ + 1)(aₓ₋₂ + 1)...(a₂ + 1) = 2ⁿ⁻¹(aₓ₋₁ + 1)(aₓ₋₂ + 1)(aₓ₋₃ + 1)...(a₁ + 1)`
    4. 양변을 공통 된 값으로 나눔 "(aₓ₋₁ + 1)(aₓ₋₂ + 1)...(a₂ + 1)"    
    `aₓ + 1 = 2ⁿ⁻¹(a₁ + 1)`
    5. 정리 (a₁ = 1 왜? 원판 한개를 옮기는 경우 이동 횟수는 1이므로)    
    `aₓ + 1 = 2ⁿ⁻¹(a₁ + 1) → aₓ + 1 = 2ⁿ⁻¹(1 + 1) → aₓ + 1 = 2ⁿ⁻¹ × 2  → aₓ = 2ⁿ - 1`    
    
  - 재귀 접근방법(수행과정)
    이동 횟수를 구할 때 보았던 3단계를 함수로 변경 즉, 하노이함수는 세 번의 과정으로 나눌 수 있음
    ```
    1단계 → 가장 큰 원판을 옮기기 위해 첫번째 막대에 있는 n-1개의 원판을 두번째 막대로 이동
            즉, 첫번째에서 두번째 막대로 가는 것을 a라고 하면, n-1번 만큼 반복 한다 = aₓ₋₁
             → 원판의 개수 : n-1, 출발지 : 첫번째 막대, 도착지 두번째 막대
    2단계 → 첫번째 막대에 남아 있는 가장 큰 원판을 세번째 막대로 이동
            = +1
             → 출발지 : 첫번째 막대, 도착지 세번째 막대
    2단계 → 두번째 막대에 있는 n-1개의 원판을 세번째 막대로 이동
            = aₓ₋₁
             → 원판의 개수 : n-1, 출발지 : 두번째 막대, 도착지 세번째 막대
    ```
    위 과정을 정리해 본다면 아래 코드와 같이 정리할 수 있음
    ```java
    void hanoi(원판 개수, 출발지, 경유지, 도착지) {
      원판 개수가 1개일 경우 (한번에 하나의 원판만 옮길 수 있으므로) 
      hanoi(n-1, 첫번째, 세번째, 두번째)
      출력 첫번째 -> 세번째
      hanoi(n-1, 두번째, 첫번째, 세번째)
    }
    ```
## Reference
  - [위키백과 하노이의 탑](https://ko.wikipedia.org/wiki/%ED%95%98%EB%85%B8%EC%9D%B4%EC%9D%98_%ED%83%91)
  - [수학하는 블로그 하노이의 탑과 점화식](http://blog.naver.com/PostView.nhn?blogId=2gumin14&logNo=221060149259)
  - [Stranger's LAB 하노이 탑 이동 순서](https://st-lab.tistory.com/96?category=852877)
  - [Parkito's on the way! 하노이의 탑 이해하기](https://shoark7.github.io/programming/algorithm/tower-of-hanoi)
***
[목차로 이동](https://github.com/youngho-j/TIL/blob/main/Algorithm/README.md "Go README.md")
