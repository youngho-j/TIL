# 재귀 알고리즘 
  - 재귀 함수 : 어떤 함수 내에서 자기 자신(함수)을 다시 호출하여 작업을 수행하는 방식의 함수   
    → 함수를 연이어 호출 시 스택처럼 메모리에 쌓임(push)   
    → 쌓인 역순으로 하나씩 실행(pop) like stack
  - 함수내에서 다시 자신을 호출한 뒤 그 함수가 끝날 때 까지 함수 호출 이후의 명령문 수행되지 X
  - stack overflow를 방지하기 위해 종료조건이 꼭 포함 되어어야함 
  
  - 실행 예제(팩토리얼)
    ~~~ java
	  public static void main(String[] args) throws IOException {
		  BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		  int num = Integer.parseInt(br.readLine());
		  System.out.println(recursive(num));
	  }
    ~~~
    ~~~ java
    public static int recursive(int n) {
      if(n <= 1) {
        return 1;
      } else {
          return n * recursive(n-1);
      }
    }
    ~~~
  - 실행 과정
    | n = 3        | n = 2        | n = 1        |       →      |              |              |              |    결과      |
    | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
    |              |              | recursive(1) |              | return 1     |              |              |              |
    |              | recursive(2) | recursive(2) |              |              | return 1 * 2 |              |              |
    | recursive(3) | recursive(3) | recursive(3) |              |              |              | return 1 * 2 * 3 | 3! = 6   |
       
  - stack overflow 
     * 각각 주어진 스택 메모리보다 데이터를 더 넣거나, 스택이 메모리가 비어있는데 거기서 데이터를 꺼내려했을때 발생
## Reference
  - https://gomguard.tistory.com/111
  - https://smile2x.tistory.com/entry/%EC%9E%AC%EA%B7%80%ED%95%A8%EC%88%98%EC%9D%98-%EC%9B%90%EB%A6%AC-%EB%B0%8F-%EB%8F%99%EC%9E%91
   
# 분할 정복법
  - 여러 알고리즘의 기본이 되는 해결 방법
  - 엄청나게 크고 방대한 문제를 조금씩 나눠가면서 용이하게 풀 수 있는 문제 단위로 나눈 뒤 그것들을 다시 합하여 해결   
    → 주어진 문제를 작은 사례로 나누고 각각의 작은 문제들을 해결하여 정복하는 방법
  - 하향식 접근 방법 → 아래로 내려가면서 작은 사례에 대한 해답을 구함으로써 최상위 사례의 해답을 구함
  - 설계전략 (상단 분할, 중앙 정복, 하단 조합)
    ```
    분할 : 문제를 동일한 유형의 여러 하위 문제로 나눔
    정복 : 가장 작은 단위의 하위 문제를 해결하여 정복
    조합 : 하위 문제에 대한 결과를 원래 문제에 대한 결과로 조합
    ```
  - 예시  
    * 이분검색, 합병정렬, 퀵정렬, 최대값 찾기, 임계값의 결정, 쉬트라센 행렬곱셈 알고리즘 등
    
  - 장, 단점
    * 장점 
      1. 문제를 나눔으로써 어려운 문제를 해결할 수 있음
      2. 문제를 나누어 해결한다는 특징상 병렬적으로 문제를 해결하는 데 큰 강점이 있음

    * 단점
      1. 함수를 재귀적으로 호출한다는 점에서 함수 호출로 인한 오버헤드가 발생 가능
      2. 스택에 다양한 데이터를 보관하고 있어야 하므로 스택 오버플로우가 발생하거나 과도한 메모리 사용을 하게 됨
      3. 문제에 따라 알고리즘의 퍼포먼스의 차이 발생 가능

## Reference
  - https://namu.wiki/w/%EB%B6%84%ED%95%A0%20%EC%A0%95%EB%B3%B5%EB%B2%95
  - https://kimch3617.tistory.com/entry/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B6%84%ED%95%A0%EC%A0%95%EB%B3%B5%EB%B2%95-Divide-and-Conquer

# 하노이의 탑 
  - 1883년 프랑스 수학자 에두아르 뤼카가 소개한 문제
    <p align="center"><img src="/img/Algorithm/Tower_of_Hanoi.jpeg" width="50%" height="60%" title="하노이탑"></img></p>
  - 재귀 호출을 이용하여 풀 수 있는 가장 유명한 예제 중 하나
  - 아래 두 가지 조건을 만족시키면서, 한 기둥에 꽂힌 원판들을 그 순서 그대로 다른 기둥으로 옮겨서 다시 쌓는 것
    1. 한 번에 하나의 원판만 옮길 수 있으며, 막대에서 막대로만 움직일 수 있다.
    2. 큰 원판이 작은 원판 위에 있어서는 안 된다.
    
  - 이동 횟수 구하기(일반항)
    <p align="center"><img src="/img/Algorithm/hanoi_find_rule.png" width="100%" height="100%" title="하노이탑 규칙 찾기"></img></p>    
    
    위의 그림을 보면 3단계의 과정을 볼 수 있음(여기서 x는 n과 같음)    
    
    ```
    1단계 → 가장 큰 원판을 옮기기 위해 첫번째 막대에 있는 n-1개의 원판을 두번째 막대로 이동
            즉, 첫번째에서 두번째 막대로 가는 것을 a라고 하면, n-1번 만큼 반복 한다 = aₓ₋₁
    2단계 → 첫번째 막대에 남아 있는 가장 큰 원판을 세번째 막대로 이동
            = +1
    2단계 → 두번째 막대에 있는 n-1개의 원판을 세번째 막대로 이동
            = aₓ₋₁
    ```
    이 과정을 하나의 식으로 나타내면 (여기서 x는 n과 같음)
    |     |1단계|2단계|3단계|
    |:---:|:---:|:---:|:---:|
    |aₓ = |aₓ₋₁|1|aₓ₋₁|
    
    위와 같은 식이 되고, 아래와 같이 나타 낼 수 있음    
    `aₓ = aₓ₋₁ + 1 + aₓ₋₁`    
    조금 더 간편하게 식을 다듬을 경우 좌변과 우변에 +1을 더한 뒤 우변을 2로 묶어 아래와 같은 식 완성    
    `→ aₓ + 1 = 2(aₓ₋₁ + 1)`
    
    일반항을 구하기 위해 위 점화식을 풀어 본다면(여기서 x는 n과 같음)
    1. x 자리에 x, x-1 ~ 2를 대입 
     ~~~
     aₓ + 1 = 2(aₓ₋₁ + 1),
     aₓ₋₁ + 1 = 2(aₓ₋₂ + 1),
     aₓ₋₂ + 1 = 2(aₓ₋₃ + 1),
     ...,
     a₂ + 1 = 2(a₁ + 1)
     ~~~
    2. 각 변끼리 곱함    
    `(aₓ + 1)(aₓ₋₁ + 1)(aₓ₋₂ + 1)...(a₂ + 1) = 2(aₓ₋₁ + 1)2(aₓ₋₂ + 1)2(aₓ₋₃ + 1)...2(a₁ + 1)`
    3. 곱한 내용 정리    
    `(aₓ + 1)(aₓ₋₁ + 1)(aₓ₋₂ + 1)...(a₂ + 1) = 2ⁿ⁻¹(aₓ₋₁ + 1)(aₓ₋₂ + 1)(aₓ₋₃ + 1)...(a₁ + 1)`
    4. 양변을 공통 된 값으로 나눔 "(aₓ₋₁ + 1)(aₓ₋₂ + 1)...(a₂ + 1)"    
    `aₓ + 1 = 2ⁿ⁻¹(a₁ + 1)`
    5. 정리 (a₁ = 1 왜? 원판 한개를 옮기는 경우 이동 횟수는 1이므로)    
    `aₓ + 1 = 2ⁿ⁻¹(a₁ + 1) → aₓ + 1 = 2ⁿ⁻¹(1 + 1) → aₓ + 1 = 2ⁿ⁻¹ × 2  → aₓ = 2ⁿ - 1`    
    
  - 재귀 접근방법(수행과정)
    이동 횟수를 구할 때 보았던 3단계를 함수로 변경 즉, 하노이함수는 세 번의 과정으로 나눌 수 있음
    ```
    1단계 → 가장 큰 원판을 옮기기 위해 첫번째 막대에 있는 n-1개의 원판을 두번째 막대로 이동
            즉, 첫번째에서 두번째 막대로 가는 것을 a라고 하면, n-1번 만큼 반복 한다 = aₓ₋₁
             → 원판의 개수 : n-1, 출발지 : 첫번째 막대, 도착지 두번째 막대
    2단계 → 첫번째 막대에 남아 있는 가장 큰 원판을 세번째 막대로 이동
            = +1
             → 출발지 : 첫번째 막대, 도착지 세번째 막대
    2단계 → 두번째 막대에 있는 n-1개의 원판을 세번째 막대로 이동
            = aₓ₋₁
             → 원판의 개수 : n-1, 출발지 : 두번째 막대, 도착지 세번째 막대
    ```
    위 과정을 정리해 본다면 아래 코드와 같이 정리할 수 있음
    ```java
    void hanoi(원판 개수, 출발지, 경유지, 도착지) {
      원판 개수가 1개일 경우 (한번에 하나의 원판만 옮길 수 있으므로) 
      hanoi(n-1, 첫번째, 세번째, 두번째)
      출력 첫번째 -> 세번째
      hanoi(n-1, 두번째, 첫번째, 세번째)
    }
    ```
## Reference
  - https://ko.wikipedia.org/wiki/%ED%95%98%EB%85%B8%EC%9D%B4%EC%9D%98_%ED%83%91
  - http://blog.naver.com/PostView.nhn?blogId=2gumin14&logNo=221060149259
  - https://st-lab.tistory.com/96?category=852877
  - https://shoark7.github.io/programming/algorithm/tower-of-hanoi
  
# 브루트 포스(Brute Force) 알고리즘

  - 문제를 해결하기 위해 **가능한 모든 경우**에 대해 모두 직접 해보는 방법
    → 완전 탐색 알고리즘
  - 설계 시, '답이 하나 이상 존재한다' 라는 가정을 세우고 모든 경우 탐색
  - 구조에 따른 종류
    * 선형 구조 (자료를 구성하는 데이터를 순차적으로 나열 시킨 형태)
      1. 순차 탐색
      ```
      - 데이터가 모인 데이터 배열의 처음부터 끝까지 차례대로 비교하여 원하는 데이터를 찾아내는 것
      
      - 단방향으로 탐색을 진행 → '선형 탐색'  
      
      - 데이터를 따로 조작 할 필요가 없음 → 단순하며, 구현이 쉬움  
      
      - 데이터가 많은 경우 비교해야할 대상이 많아 짐 → 비효율적임  
      
      - 시간 복잡도(탐색 대상 요소 n개로 가정)
        → 최선의 경우 (비교 연산 횟수 1) → 대부분 긍정적인 결과가 나옴 
        → 평균의 경우 (비교 연산 횟수 1) → 광범위한 자료를 수집해야 하기 때문에 최악의 경우를 많이 따짐 
        → 최악의 경우 (비교 연산 횟수 n) → 데이터 수가 n개 일 때, 연산 횟수는 n이라고 볼 수 있음
        즉, T(n) = n
      ```
    * 비선형 구조 (하나의 자료 뒤에 여러개의 자료가 존재 할 수 잇는 것)
      1. BFS(넓이 우선 탐색)
      2. DFS(깊이 우선 탐색)
## Reference
  - https://steemit.com/kr-dev/@gyeryak/easyalgo-2-bruteforce
  - https://allg.tistory.com/29
  - https://bite-sized-learning.tistory.com/225
  - https://blog.hexabrain.net/245

# 삽입정렬

  - **손안의 카드를 정렬하는 방법과 유사**    
    <p align="center"><img src="/img/Algorithm/Insertion_Sort.gif" width="100%" height="100%" title="삽입정렬 이미지"></img></p>  
  
  - 자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열부분과 비교하여  
    자신의 위치를 찾아 삽입하여 정렬 완성하는 알고리즘
    ```
    즉, 두 번째 자료부터 시작하여 그 앞(왼쪽)의 자료들과 비교하여 삽입할 위치를 지정한 후   
    자료를 뒤로 옮기고 지정한 자리에 자료를 삽입하여 정렬하는 알고리즘
    
    Point
      1. 처음 정렬 시작 시 두번째 인덱스부터 시작(첫 번째 인덱스는 정렬된 것으로 본다.)
      2. 선택한 원소를 key에 저장
      3. key와 선택한 원소의 이전 원소들과 비교하면서 삽입
      4. 선택한 원소의 다음 원소를 선택하여 3번 반복
    ```  
  - 장점
    * 구현이 간단함
    * 선택 정렬이나 버블 정렬과 같은 O(n²) 알고리즘에 비교하여 빠르고, 안정 정렬이고 in-place 알고리즘이다.  
    
  - 단점
    * 배열이 길어질수록 효율 ↓
  
  - 시간 복잡도(탐색 대상 요소 n개로 가정)  
    → 최선의 경우 (비교 연산 횟수 = 이미 정렬되어 이동 없이 1번 비교) →  O(n)  
    → 최악의 경우 (비교 연산 횟수 = 역으로 정렬되어 있는 경우) →  O(n²)
  
## Reference
  - https://ko.wikipedia.org/wiki/%EC%82%BD%EC%9E%85_%EC%A0%95%EB%A0%AC
  - https://devjin-blog.com/sort-algorithm-1/
  - https://zeddios.tistory.com/20
  - https://gmlwjd9405.github.io/2018/05/06/algorithm-insertion-sort.html
  - http://blog.naver.com/PostView.nhn?blogId=redwave102&logNo=80073417047
