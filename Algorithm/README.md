# 목차
  - [알고리즘](#알고리즘)
  - [재귀 알고리즘](#재귀-알고리즘)
  - [분할 정복법](#분할-정복법)
  - [하노이의 탑](#하노이의-탑)
  - [브루트 포스 알고리즘](#브루트-포스-알고리즘)
  - [삽입 정렬](#삽입-정렬)
  - [계수 정렬](#계수-정렬)
  - [백트래킹(Backtracking)](#백트래킹backtracking)
***
# 알고리즘 
  - 알고리즘이란?
    * 어떠한 문제를 해결하기 위한 '일련의 절차를 공식화한 형태(해결방법)'로 표현한 것
    * 해결방법은 여러 가지로 존재 할 수 있다.
    * 따라서 시간 복잡도가 가장 낮은 알고리즘을 선택하여 사용하여야 한다!
  - 알고리즘 실행시간
    * 컴퓨터가 알고리즘 코드를 실행하는 속도에 의존
    * 코드 실행 속도는 '컴퓨터의 처리속도, 언어종류, 컴파일러의 속도에 달려있음'
      
  - 알고리즘에 필요한 기본 개념
     * 점근적 분석
      ```
      각 알고리즘이 주어진 데이터의 크기를 기준으로 수행시간 혹은 사용공간이 얼마나 되는지를  
      객관적으로 비교할 수 있는 기준을 제시
      ```
    * 점근적 표기법(복잡도를 나타내는 방법)
      - 입력값의 크기에 따른 함수의 증가량(성장률)에 가장 큰 영향을 주는 항만 계산하여 표기
      - 어떤 함수의 증가 양상을 다른 함수와의 비교로 표현하는 수론과 해석학의 방법
      - 알고리즘의 복잡도를 단순화할 때나 무한급수의 뒷부분을 간소화시 사용
      - 특히, 알고리즘의 복잡도를 나타내는 용어로는 "계산 복잡도 이론" 또는 "시간복잡도"로  
        **Big O 표기법**이 일반적으로 사용  
        왜? 평균인 세타를 사용하면 가장 정확하고 좋지만 평가가 까다로움,  
        최악의 경우 판단시 평균과 가까운 성능으로 예측하기 쉽기 때문에
        ```
        1. 최선의 경우 (Big-Ω Notation) : 점근적 하한
        2. 평균의 경우 (Big-θ Notation) : 점근적 하한과 점근적 상한의 교집합
        3. 최악의 경우 (Big-O Notation) : 점근적 상한(최악의 상황에서도 이 성능 이상을 보장한다.)
        ```
    * Big-O 표기법  
      ```
      불필요한 연산을 제거하여 알고리즘분석을 쉽게 할 목적으로 사용  
      
      알고리즘의 효율성을 나타내는 지표
      
      최악의 상항만을 염두해 두기에 상수나, 영향력이 없는 항은 철저하게 무시  
      
      Big-O로 측정되는 복잡성에는 시간과 공간 복잡도가 있음
      ```
      <p align="center"><img src="/img/Algorithm/Big-O Complexity chart.png" width="70%" height="60%" title="Big-O 복잡도 이미지"></img></p>
      
    * 공간 복잡도(Space Complexity)
      ```
      알고리즘 실행 후 완료하는데 필요한 **메모리의 양**  
      
      FYR) 저장 기술의 발달로 인해 현재는 시간 복잡도를 우선 고려하는 경우가 많다.
      ```
    * 시간 복잡도(Time Complexity)  
      ```
      입력 값의 개수와 알고리즘의 처리 시간과의 상관관계를 표현한 말  
      
      알고리즘을 수행하기 위해 프로세스가 수행해야하는 연산을 수치화 한 것  
      → 입력된 N의 크기에 따라 실행되는 조작의 수
      
      왜 연산 수치로 판별하는지? 알고리즘 실행시간은 컴퓨터의 처리속도, 프로그래밍 언어에 따라
      편차가 크기 때문에 명령어의 실행횟수만 고려
      ```
     
      중요하게 보는 것은 가장 큰 영향을 미치는 n의 단위
      |실행횟수|Big-O표기|영향|
      |:--:|:--:|:---|
      |1|O(1)|→ 상수|
      |2n+20|O(n)|→ n이 가장 큰 영향을 미침|
      |3n²|O(n²)|→ n²이 가장 큰 영향을 미침|
      |(3^N)M|O((3^N)M)|→ (3^N)M이 가장 큰 영향을 미침|
      
      문제 해결 단계
      ```
      O(1) – 상수 시간 : 문제를 해결하는데 오직 한 단계만 처리
      
      O(log n) – 로그 시간 : 문제를 해결하는데 필요한 단계들이 연산마다 특정 요인에 의해 줄어듬
      
      O(n) – 직선적 시간 : 문제를 해결하기 위한 단계의 수와 입력값 n이 1:1 관계를 가짐
      
      O(n log n) - 로그 선형 시간: 문제를 해결하기 위한 단계의 수가 N*(log2N) 번만큼의 수행시간을 가짐
      
      O(n²) – 2차 시간 : 문제를 해결하기 위한 단계의 수는 입력값 n의 제곱
      
      O(C^n) – 지수 시간 : 문제를 해결하기 위한 단계의 수는 주어진 상수값 C 의 n 제곱
      ```
      <p align="center"><img src="/img/Algorithm/Big-O function ranking.png" width="40%" height="50%" title="Big-O 시간복잡도 랭킹"></img></p>
      
      구하는 요령(유형 파악 예시)
      ```
      하나의 루프를 사용하여 단일 요소 집합을 반복 하는 경우 : O (n)
      
      컬렉션의 절반 이상 을 반복 하는 경우 : O (n / 2) -> O (n)
      
      두 개의 다른 루프를 사용하여 두 개의 개별 콜렉션을 반복 할 경우 : O (n + m) -> O (n)
      
      두 개의 중첩 루프를 사용하여 단일 컬렉션을 반복하는 경우 : O (n²)
      
      두 개의 중첩 루프를 사용하여 두 개의 다른 콜렉션을 반복 할 경우 : O (n * m) -> O (n²)
      
      컬렉션 정렬을 사용하는 경우 : O(n*log(n))
      ```
      정렬 알고리즘 시간복잡도 비교
      <p align="center"><img src="/img/Algorithm/Array Sorting.png" width="70%" height="60%" title="정렬 알고리즘 시간복잡도 비교"></img></p>  
      
      자료구조 시간복잡도 비교
      <p align="center"><img src="/img/Algorithm/Data Structure image.png" width="80%" height="70%" title="자료구조 시간복잡도 비교"></img></p>
## Reference
  - [Yena Choi 알고리즘 공부 시작 방법 및 순서](https://blog.yena.io/studynote/2018/11/14/Algorithm-Basic.html)
  - [알고리즘과 성능 척도 #1](https://godgod732.tistory.com/9?category=659135)
  - [위키백과 점근 표기법](https://ko.wikipedia.org/wiki/%EC%A0%90%EA%B7%BC_%ED%91%9C%EA%B8%B0%EB%B2%95)
  - [Khan Academy 점근적 표기법](https://ko.khanacademy.org/computing/computer-science/algorithms/asymptotic-notation/a/asymptotic-notation)
  - [견우와 직녀 점근적 표기법](https://ledgku.tistory.com/31)
  - [Chulgil.Lee 알고리즘의 시간 복잡도와 Big-O 쉽게 이해하기](https://blog.chulgil.me/algorithm/)
  - [Big-O Complexity Chart](https://www.bigocheatsheet.com/)
  - [까스활명문.log 시간복잡도와 Big_O-표기법](https://velog.io/@jeongho3786/Time-Complexity-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84%EC%99%80-Big-O-%ED%91%9C%EA%B8%B0%EB%B2%95)
***
# 재귀 알고리즘 
  - 재귀 함수 : 어떤 함수 내에서 자기 자신(함수)을 다시 호출하여 작업을 수행하는 방식의 함수   
    → 함수를 연이어 호출 시 스택처럼 메모리에 쌓임(push)   
    → 쌓인 역순으로 하나씩 실행(pop) like stack
  - 함수내에서 다시 자신을 호출한 뒤 그 함수가 끝날 때 까지 함수 호출 이후의 명령문 수행되지 X
  - stack overflow를 방지하기 위해 종료조건이 꼭 포함 되어어야함 
  
  - 실행 예제(팩토리얼)
    ~~~ java
	  public static void main(String[] args) throws IOException {
		  BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		  int num = Integer.parseInt(br.readLine());
		  System.out.println(recursive(num));
	  }
    ~~~
    ~~~ java
    public static int recursive(int n) {
      if(n <= 1) {
        return 1;
      } else {
          return n * recursive(n-1);
      }
    }
    ~~~
  - 실행 과정
    | n = 3        | n = 2        | n = 1        |       →      |              |              |              |    결과      |
    | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
    |              |              | recursive(1) |              | return 1     |              |              |              |
    |              | recursive(2) | recursive(2) |              |              | return 1 * 2 |              |              |
    | recursive(3) | recursive(3) | recursive(3) |              |              |              | return 1 * 2 * 3 | 3! = 6   |
       
  - stack overflow 
     * 각각 주어진 스택 메모리보다 데이터를 더 넣거나, 스택이 메모리가 비어있는데 거기서 데이터를 꺼내려했을때 발생
## Reference
  - https://gomguard.tistory.com/111
  - https://smile2x.tistory.com/entry/%EC%9E%AC%EA%B7%80%ED%95%A8%EC%88%98%EC%9D%98-%EC%9B%90%EB%A6%AC-%EB%B0%8F-%EB%8F%99%EC%9E%91
***
# 분할 정복법
  - 여러 알고리즘의 기본이 되는 해결 방법
  - 엄청나게 크고 방대한 문제를 조금씩 나눠가면서 용이하게 풀 수 있는 문제 단위로 나눈 뒤 그것들을 다시 합하여 해결   
    → 주어진 문제를 작은 사례로 나누고 각각의 작은 문제들을 해결하여 정복하는 방법
  - 하향식 접근 방법 → 아래로 내려가면서 작은 사례에 대한 해답을 구함으로써 최상위 사례의 해답을 구함
  - 설계전략 (상단 분할, 중앙 정복, 하단 조합)
    ```
    분할 : 문제를 동일한 유형의 여러 하위 문제로 나눔
    정복 : 가장 작은 단위의 하위 문제를 해결하여 정복
    조합 : 하위 문제에 대한 결과를 원래 문제에 대한 결과로 조합
    ```
  - 예시  
    * 이분검색, 합병정렬, 퀵정렬, 최대값 찾기, 임계값의 결정, 쉬트라센 행렬곱셈 알고리즘 등
    
  - 장, 단점
    * 장점 
      1. 문제를 나눔으로써 어려운 문제를 해결할 수 있음
      2. 문제를 나누어 해결한다는 특징상 병렬적으로 문제를 해결하는 데 큰 강점이 있음

    * 단점
      1. 함수를 재귀적으로 호출한다는 점에서 함수 호출로 인한 오버헤드가 발생 가능
      2. 스택에 다양한 데이터를 보관하고 있어야 하므로 스택 오버플로우가 발생하거나 과도한 메모리 사용을 하게 됨
      3. 문제에 따라 알고리즘의 퍼포먼스의 차이 발생 가능

## Reference
  - https://namu.wiki/w/%EB%B6%84%ED%95%A0%20%EC%A0%95%EB%B3%B5%EB%B2%95
  - https://kimch3617.tistory.com/entry/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B6%84%ED%95%A0%EC%A0%95%EB%B3%B5%EB%B2%95-Divide-and-Conquer
***
# 하노이의 탑 
  - 1883년 프랑스 수학자 에두아르 뤼카가 소개한 문제
    <p align="center"><img src="/img/Algorithm/Tower_of_Hanoi.jpeg" width="50%" height="60%" title="하노이탑"></img></p>
  - 재귀 호출을 이용하여 풀 수 있는 가장 유명한 예제 중 하나
  - 아래 두 가지 조건을 만족시키면서, 한 기둥에 꽂힌 원판들을 그 순서 그대로 다른 기둥으로 옮겨서 다시 쌓는 것
    1. 한 번에 하나의 원판만 옮길 수 있으며, 막대에서 막대로만 움직일 수 있다.
    2. 큰 원판이 작은 원판 위에 있어서는 안 된다.
    
  - 이동 횟수 구하기(일반항)
    <p align="center"><img src="/img/Algorithm/hanoi_find_rule.png" width="100%" height="100%" title="하노이탑 규칙 찾기"></img></p>    
    
    위의 그림을 보면 3단계의 과정을 볼 수 있음(여기서 x는 n과 같음)    
    
    ```
    1단계 → 가장 큰 원판을 옮기기 위해 첫번째 막대에 있는 n-1개의 원판을 두번째 막대로 이동
            즉, 첫번째에서 두번째 막대로 가는 것을 a라고 하면, n-1번 만큼 반복 한다 = aₓ₋₁
    2단계 → 첫번째 막대에 남아 있는 가장 큰 원판을 세번째 막대로 이동
            = +1
    2단계 → 두번째 막대에 있는 n-1개의 원판을 세번째 막대로 이동
            = aₓ₋₁
    ```
    이 과정을 하나의 식으로 나타내면 (여기서 x는 n과 같음)
    |     |1단계|2단계|3단계|
    |:---:|:---:|:---:|:---:|
    |aₓ = |aₓ₋₁|1|aₓ₋₁|
    
    위와 같은 식이 되고, 아래와 같이 나타 낼 수 있음    
    `aₓ = aₓ₋₁ + 1 + aₓ₋₁`    
    조금 더 간편하게 식을 다듬을 경우 좌변과 우변에 +1을 더한 뒤 우변을 2로 묶어 아래와 같은 식 완성    
    `→ aₓ + 1 = 2(aₓ₋₁ + 1)`
    
    일반항을 구하기 위해 위 점화식을 풀어 본다면(여기서 x는 n과 같음)
    1. x 자리에 x, x-1 ~ 2를 대입 
     ~~~
     aₓ + 1 = 2(aₓ₋₁ + 1),
     aₓ₋₁ + 1 = 2(aₓ₋₂ + 1),
     aₓ₋₂ + 1 = 2(aₓ₋₃ + 1),
     ...,
     a₂ + 1 = 2(a₁ + 1)
     ~~~
    2. 각 변끼리 곱함    
    `(aₓ + 1)(aₓ₋₁ + 1)(aₓ₋₂ + 1)...(a₂ + 1) = 2(aₓ₋₁ + 1)2(aₓ₋₂ + 1)2(aₓ₋₃ + 1)...2(a₁ + 1)`
    3. 곱한 내용 정리    
    `(aₓ + 1)(aₓ₋₁ + 1)(aₓ₋₂ + 1)...(a₂ + 1) = 2ⁿ⁻¹(aₓ₋₁ + 1)(aₓ₋₂ + 1)(aₓ₋₃ + 1)...(a₁ + 1)`
    4. 양변을 공통 된 값으로 나눔 "(aₓ₋₁ + 1)(aₓ₋₂ + 1)...(a₂ + 1)"    
    `aₓ + 1 = 2ⁿ⁻¹(a₁ + 1)`
    5. 정리 (a₁ = 1 왜? 원판 한개를 옮기는 경우 이동 횟수는 1이므로)    
    `aₓ + 1 = 2ⁿ⁻¹(a₁ + 1) → aₓ + 1 = 2ⁿ⁻¹(1 + 1) → aₓ + 1 = 2ⁿ⁻¹ × 2  → aₓ = 2ⁿ - 1`    
    
  - 재귀 접근방법(수행과정)
    이동 횟수를 구할 때 보았던 3단계를 함수로 변경 즉, 하노이함수는 세 번의 과정으로 나눌 수 있음
    ```
    1단계 → 가장 큰 원판을 옮기기 위해 첫번째 막대에 있는 n-1개의 원판을 두번째 막대로 이동
            즉, 첫번째에서 두번째 막대로 가는 것을 a라고 하면, n-1번 만큼 반복 한다 = aₓ₋₁
             → 원판의 개수 : n-1, 출발지 : 첫번째 막대, 도착지 두번째 막대
    2단계 → 첫번째 막대에 남아 있는 가장 큰 원판을 세번째 막대로 이동
            = +1
             → 출발지 : 첫번째 막대, 도착지 세번째 막대
    2단계 → 두번째 막대에 있는 n-1개의 원판을 세번째 막대로 이동
            = aₓ₋₁
             → 원판의 개수 : n-1, 출발지 : 두번째 막대, 도착지 세번째 막대
    ```
    위 과정을 정리해 본다면 아래 코드와 같이 정리할 수 있음
    ```java
    void hanoi(원판 개수, 출발지, 경유지, 도착지) {
      원판 개수가 1개일 경우 (한번에 하나의 원판만 옮길 수 있으므로) 
      hanoi(n-1, 첫번째, 세번째, 두번째)
      출력 첫번째 -> 세번째
      hanoi(n-1, 두번째, 첫번째, 세번째)
    }
    ```
## Reference
  - [위키백과 하노이의 탑](https://ko.wikipedia.org/wiki/%ED%95%98%EB%85%B8%EC%9D%B4%EC%9D%98_%ED%83%91)
  - [수학하는 블로그 하노이의 탑과 점화식](http://blog.naver.com/PostView.nhn?blogId=2gumin14&logNo=221060149259)
  - [Stranger's LAB 하노이 탑 이동 순서](https://st-lab.tistory.com/96?category=852877)
  - [Parkito's on the way! 하노이의 탑 이해하기](https://shoark7.github.io/programming/algorithm/tower-of-hanoi)
*** 
# 브루트 포스 알고리즘

  - 문제를 해결하기 위해 **가능한 모든 경우**에 대해 모두 직접 해보는 방법
    → 완전 탐색 알고리즘
  - 설계 시, '답이 하나 이상 존재한다' 라는 가정을 세우고 모든 경우 탐색
  - 구조에 따른 종류
    * 선형 구조 (자료를 구성하는 데이터를 순차적으로 나열 시킨 형태)
      1. 순차 탐색
      ```
      - 데이터가 모인 데이터 배열의 처음부터 끝까지 차례대로 비교하여 원하는 데이터를 찾아내는 것
      
      - 단방향으로 탐색을 진행 → '선형 탐색'  
      
      - 데이터를 따로 조작 할 필요가 없음 → 단순하며, 구현이 쉬움  
      
      - 데이터가 많은 경우 비교해야할 대상이 많아 짐 → 비효율적임  
      
      - 시간 복잡도(탐색 대상 요소 n개로 가정)
        → 최선의 경우 (비교 연산 횟수 1) → 대부분 긍정적인 결과가 나옴 
        → 평균의 경우 (비교 연산 횟수 1) → 광범위한 자료를 수집해야 하기 때문에 최악의 경우를 많이 따짐 
        → 최악의 경우 (비교 연산 횟수 n) → 데이터 수가 n개 일 때, 연산 횟수는 n이라고 볼 수 있음
        즉, T(n) = n
      ```
    * 비선형 구조 (하나의 자료 뒤에 여러개의 자료가 존재 할 수 잇는 것)
      1. BFS(넓이 우선 탐색)
      2. DFS(깊이 우선 탐색)
## Reference
  - [steemit 브루트 포스](https://steemit.com/kr-dev/@gyeryak/easyalgo-2-bruteforce)
  - [Allg 자료구조란?](https://allg.tistory.com/29)
  - [bite-sized-learning 순차탐색이란?](https://bite-sized-learning.tistory.com/225)
  - [끝나지 않는 프로그래밍 일기 탐색 알고리즘 - 순차탐색](https://blog.hexabrain.net/245)
***
# 삽입 정렬
  - Insertion Sort
  - **손안의 카드를 정렬하는 방법과 유사**    
    <p align="center"><img src="/img/Algorithm/Insertion_Sort.gif" width="40%" height="50%" title="삽입정렬 이미지"></img></p>  
  
  - 자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열부분과 비교하여  
    자신의 위치를 찾아 삽입하여 정렬 완성하는 알고리즘
    ```
    즉, 두 번째 자료부터 시작하여 그 앞(왼쪽)의 자료들과 비교하여 삽입할 위치를 지정한 후   
    자료를 뒤로 옮기고 지정한 자리에 자료를 삽입하여 정렬하는 알고리즘
    
    Point
      1. 처음 정렬 시작 시 두번째 인덱스부터 시작(첫 번째 인덱스는 정렬된 것으로 본다.)
      2. 선택한 원소를 key에 저장
      3. key와 선택한 원소의 이전 원소들과 비교하면서 삽입
      4. 선택한 원소의 다음 원소를 선택하여 3번 반복
    ```  
  - 장점
    * 구현이 간단함
    * 선택 정렬이나 버블 정렬과 같은 O(n²) 알고리즘에 비교하여 빠르고, 안정 정렬이고 in-place 알고리즘이다.  
    
  - 단점
    * 배열이 길어질수록 효율 ↓
  
  - 시간 복잡도(탐색 대상 요소 n개로 가정)  
    → 최선의 경우 (비교 연산 횟수 = 이미 정렬되어 이동 없이 1번 비교) →  O(n)  
    → 최악의 경우 (비교 연산 횟수 = 역으로 정렬되어 있는 경우) →  O(n²)
  
## Reference
  - [위키백과 삽입정렬](https://ko.wikipedia.org/wiki/%EC%82%BD%EC%9E%85_%EC%A0%95%EB%A0%AC)
  - [DevJin-Blog Stable Sort, inplace algorithm이란?](https://devjin-blog.com/sort-algorithm-1/)
  - [ZeddiOS 정렬 알고리즘 정리1](https://zeddios.tistory.com/20)
  - [Heee's Development Blog 삽입정렬이란?](https://gmlwjd9405.github.io/2018/05/06/algorithm-insertion-sort.html)
  - [열쓰 삽입정렬](http://blog.naver.com/PostView.nhn?blogId=redwave102&logNo=80073417047)
***
# 계수 정렬

  - Counting Sort
  - 숫자의 개수를 센 후 누적 합을 구하고, 다시 숫자를 넣어주는 방식의 정렬
  - **특정한 범위(Ex) 0~100) 안**에 있을 때 사용
    <p align="center"><img src="/img/Algorithm/CountingSort.gif" width="80%" height="80%" title="계수정렬 애니메이션"></img></p>  
    
  - 실행 과정
    ```
    1. A배열을 처음부터 끝까지 돌면서 각 요소가 몇번 나왔는지 count 배열에 저장
    2. count 배열에 저장된 등장 횟수를 누적합으로 변경  
       누적합을 통해 해당 숫자가 인덱스 번호 안에 속한다는 것을 알 수 있음 즉, 위치를 알 수 있음
    3. count 배열의 누적 합을 통해 위치를 참고하여 A배열을 뒤에서 앞으로 순회하면서 정렬된 B배열에 넣어줌
    ```  
   - 장점
     * 비교를 하지 않고 정렬하는 Counting Sort 알고리즘의 시간복잡도는 O(n+k) 
     * 안정 정렬(같은 숫자라도 정렬 시 순서가 섞이지 않음)
    
  - 단점
    * 대부분의 상황에서 엄청난 메모리 낭비 야기 할 수 있음(숫자 개수 저장 공간, 결과 저장 공간)  
      → 누적합 배열에 대한 접근을 O(n) 달성하기 위해 정렬할 배열에 포함된 숫자의 최댓값 만큼의 메모리를 필요
    * 가장 큰 숫자에 영향을 받음

  - 시간 복잡도  
    → 최상의 경우 → O(n + k)  
	`n : 데이터갯수`  
        `k : 범위(정렬할 수 중 가장 큰 값)`  
    → 최악의 경우 → O(n!)

## Reference
  - [개발냥발 특수 정렬 알고리즘](https://coding-nyan.tistory.com/7)
  - [멍멍멍 Counting Sort : 계수 정렬](https://bowbowbow.tistory.com/8)
  - [얍문's Coding World.. 정렬별 장단점 및 시간복잡도](https://yabmoons.tistory.com/250)
  - [Burton Rosenberg Counting Sort](http://www.cs.miami.edu/home/burt/learning/Csc517.091/workbook/countingsort.html)
---

# 백트래킹(Backtracking)
  - 백트래킹?
    * 상태공간을 트리로 나타낼 수 있을 때 적합한 방식  
      → 일종의 트리 탐색 알고리즘으로 봐도 됨  
    
    * 일반적인 알고리즘 중 하나이며, CSP를 해결하기 위해 쓰임  
    
    * CSP? 
      + Contstrain Satisfaction Problems : 특정 조건을 만족하는 문제
	  
	* 즉,  백트래킹이란 **조건을 만족하는** 모든 경우의 수를 살펴보는 것  
	  → 조건을 만족하는 경우에 대해서만 모든 조합을 살펴봄  
	  따라서, 경우에 따라서 모든 경우의 수를 찾는 것 보다 훨씬 빠를 수 있음   
  
  - 백트래킹 유망성 판단
    * 노드의 유망성 판단(promising)
      → 해가 될 만한지 판단(해가 될 가능성 존재하는지)
    * 유망하지 않을 경우 해당 노드의 이전(부모)로 돌아가 (Backtracking) 다음 자식으로 이동
    * 유망하지 않은 노드에 가지 않는 것(가지치기, pruning)
  - 백트래킹 방식
    * 깊이 우선 탐색(Depth First Search)
      ```
      - like 미로찾기
      
      - 상태공간을 나타낸 트리에서 바닥에 도달할 때까지 한쪽 방향으로만 내려가는 방식
        → 한 방향으로 들어가서 막다른 길(트리의 바닥)에 다다르면 왔던 길을 돌아 다른 방향으로 이동  
        → 목표지점(답)이 나올 때까지 반복  
        
      - 재귀함수로 구현 가능, 스택으로 구현 가능
      ```
    * 너비 우선 탐색(Breadth First Search)
      ```
      - 모든 분기점을 다 검사하면서 진행하는 방식
      
      - 큐를 써서 구현
      
      - 각 경우를 검사하면서 발생하는 새로운 경우를 큐에 집어 넣음  
        → 검사한 원소는 큐에서 뺌
      
      - 장점 : DFS가 못건드리는 문제를 풀 수 있음
      
      - 단점 : 공간 복잡도가 너무 커 가지치기를 제대로 안할 경우  
        DFS보다 오버플로우 발생 가능성 높음
      ```
    * 최선 우선 탐색(Best First Search/Heuristic Search)
      ```
      - BFS에서 조금 더 발전한 방식
      
      - 우선순위 큐(보통은 힙)를 써서 구현
      
      - 현재 가장 최적인 경우를 우선적으로 검사
      
      - 가지치기를 적용하면 상당히 효과적인 방법이 될 수 있음
      ```
    
  - 대표 예제
    * N-Queen 
      + N×N 크기의 체스판에서 최대한 많은 수의 퀸을   
        서로 공격하지 않도록 두는 경우의 수를 구하는 문제  
      + 수행방법  
        ```
        조건(CSP)   
        : 퀸을 k컬럼에 두기 위해 왼쪽, 왼쪽 위, 아래 대각선에 퀸이 없어야함  
        
        1. 한 컬럼에 퀸 위치
        
        2. 오른쪽 컬럼 가능한 자리에 퀸 두기
        
        3. 2번 계속 반복 수행 후 N개의 퀸이 모두 놓일 경우 count 증가
        
        4. 성공 직전의 상태로 되돌림(back) Point!
        
        5. N번째 컬럼 중 다른 칸 시도
        
        6. 없을 경우 N-1번째 컬럼에 있는 Queen을 들어 가능한 칸으로 시도
        
        7. 다시 N번째 컬럼에 둘 수 있는 곳 찾음
       
        8. 각 컬럼별로 모든 경우의 시도를 했으면 되돌아가 가능한 위치 탐색
        ```  
  
## Reference
  - [백준 N과 M(1)](https://st-lab.tistory.com/114?category=862595)
  - [오뚝이 개발자 백트래킹](https://otugi.tistory.com/88)
  - [Jeong Dowon Backtraking 이해하기](https://jeongdowon.medium.com/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-backtracking-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-13492b18bfa1)
  - [나무위키 백트래킹](https://namu.wiki/w/%EB%B0%B1%ED%8A%B8%EB%9E%98%ED%82%B9)
---
