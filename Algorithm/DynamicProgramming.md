# 동적 계획법
  - Dynamic Programming(DP)  
  
  - 어떤 주어진 문제를 간단한 작은 문제로 나눠서 푸는 알고리즘  
    즉, 어떤 문제를 작은 문제로 쪼개서 풀어나가면서 반복되는 호출을 줄이는 것  
  
  - 부분 문제 반복과 최적 부분 구조를 가지고 있는 알고리즘을 일반적인 방법에 비해 더욱 적은 시간 내에 풀때 사용
  
  - 원리
    * 문제를 여러개의 하위문제로 나눔  
    
    * 하위문제를 해결한 값을 계산  
    
    * 계산한 값을 저장하여 같은 문제가 나왔을때 사용  
      `Memoization` - 이미 풀린 하위문제를 다시 풀지 않고 재활용하는 것  
    * 결합하여 문제 해결  

  - 최단 경로 문제, 행렬의 제곱 문제등 최적화에 사용
  
  - 그리디 알고리즘과 비교
    * 동적계획법은 가능한 모든 방법을 고려해야한다는 단점을 지님  
      이 단점을 극복하기 위해 그리디 알고리즘 등장  
    
    * 그리디 알고리즘은 항상 최적해를 구해주진 않음
  
    * A 지점에서 B 지점으로 가능한 빠르게 이동한 경로 계산시
      ``` 
      * 그리디 : 순간순간 구간마다 가장 빠른 경로를 검색하여 찾음  
                 즉효성이 있지만, 항상 최적의 경로를 찾아주지 않음
       
      * DP : 모든 상황을 전부 감안하여 최적의 경로 찾음
             약간의 시간이 걸리지만 가장 빠른길임을 알 수 있음
      ```

  - 속성  
    피보나치 수열을 예시로 가정 
    1. 부분 문제가 겹침(Overlapping Subproblem)  
    ```
    Fₒ = Fₒ₋₁ + Fₒ₋₂
    위 식에서Fₒ 를 큰 문제로 생각,  Fₒ₋₁,  Fₒ₋₂를 작은 문제로 생각 
    ```
    2. 최적 부분 구조(Optimal Substructure)  
    ```
    Fₒ₋₁ + Fₒ₋₂(작은 문제의 합) 로 Fₒ (문제의 답)를 구할
    작은 문제는 이미 풀린 값이므로 다시 풀지 않고 재활용한다. 
    ```
  - 방식
    1. Top-Down  
    ```
    1. 큰 문제를 작은 문제로 나눔
    2. 작은 문제를 푼다.
    3. 푼 값을 저장

    재귀 호출 방식
    ```  
  
    2. Bottom-Up    
    ```
    1. 가장 작은 문제부터 쓰고 저장
    2. 문제의 크기를 크게 만들면서 문제 풀기
    3. 작은 문제를 풀면서 큰문제의 답을 구함
    
    반복문 사용
    ```
## Reference
  - [velog.io 동적계획법](https://velog.io/@polynomeer/%EB%8F%99%EC%A0%81-%EA%B3%84%ED%9A%8D%EB%B2%95Dynamic-Programming)
  - [나를위한노트 동적계획법정리](https://developer-mac.tistory.com/77?category=313126)
  - [위키백과 동적계획법](https://ko.wikipedia.org/wiki/%EB%8F%99%EC%A0%81_%EA%B3%84%ED%9A%8D%EB%B2%95)
  - [Stranger's LAB 피보나치수2](https://st-lab.tistory.com/123) 
***
[목차로 이동](https://github.com/youngho-j/TIL/blob/main/Algorithm/README.md "Go README.md")
