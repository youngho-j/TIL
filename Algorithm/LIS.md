# LIS
  - Longest Increasing Subsequence

  - 최장 증가 수열, 최대 증가 부분 수열  
  
  - 어떤 수열에서 특정 부분을 지워서 만들어낼 수 있는 증가 부분 수열 중 가장 긴 수열  
    `부분 수열의 숫자들은 원 배열에서 위치가 이어져 있지 않아도 됨`  
  
  - 부분 수열?  
    어떤 수열에서 `0개 이상의 숫자를 지운 결과`  
    원 수열의 부분 수열이라고 부름  
    Ex) 4 3 7 6 9의 부분 수열은? `4 7 6`  
    
  - 증가 부분 수열?  
    `중복된 숫자가 없고`, `오름 차순으로 정렬`되어 있는 부분 수열  
    여기에서 오름 차순으로 정렬되어 있다는 것은 `두 인접한 숫자 중 앞의 것이 항상 더 작다는 뜻`이므로  
    `순 증가`한다고 할 수 있음
    Ex)  4 3 7 6 9의 증가 부분 수열은? `3 6 9`  
    
    참고
    두 인접한 숫자가 같을 수도 있을 때는 수열이 `단조 증가` 한다고 할 수 있음 
    Ex) 1 2 2 4  
  
  - LIS 길이 구하기 문제
    - 시간 복잡도 : O(N²)  
      ```
      주어진 원 배열 : A
      부분 수열의 길이를 구하기 위한 새로운 배열 : D
      원 배열의 값 위치 : i
      
      조건 : 원 배열의 수가 증가 부분 수열의 마지막 값이 되려면,   
             원 배열의 수가 추가 되기 전 `증가 부분 수열의 마지막 값이 원 배열의 수보다 작은 값이 되어야함`.  
      
      해당 조건을 만족시 A[i](원 배열 중 i 위치의 값)를 마지막 값으로 가지는 가장 긴 증가 부분 수열의 길이는  
      A[i]가 추가될 수 있는 증가 부분 수열 중 가장 긴 수열의 길이에 1을 더한 값이 됨
      ```  
     - 예시 이미지(해당 값을 가지는 값부터 거꾸로 이어 나감)  
       ![image](https://user-images.githubusercontent.com/65080004/117260460-12428000-ae8a-11eb-814b-c367575ea8e4.png)  
       ```
       1. i = 1, A[1] = 10 이므로, A[0] = 0 뒤에 붙을 수 있음  
          따라서, D[1] = D[0] + 1 즉, D[1] = 1  
       
       2. i = 2, A[2] = 20 이므로, A[0] = 0, A[1] = 10 뒤에 붙을 수 있음  
          D[0] = 0, D[1] = 1에서 D[1]이 가장 크므로, D[2] = D[1] + 1 즉, D[2] = 2
       
       3. i = 3, A[3] = 10 이므로, A[0] = 0 뒤에 붙을 수 있음 따라서, D[3] = D[0] + 1 즉, D[3] = 1
       
       4. i = 4, A[4] = 30 이므로, A[0] = 0, A[1] = 10, A[2] = 20, A[3] = 10 뒤에 붙을 수 있음  
          D[0] = 0, D[1] = 1, D[2] = 2, D[3] = 1에서 D[2]이 가장 크므로, D[4] = D[2] + 1 즉, D[4] = 3
       
       5. i = 5, A[5] = 20 이므로, A[0] = 0, A[1] = 10, A[2] = 20, A[3] = 10 뒤에 붙을 수 있음  
          D[0] = 0, D[1] = 1, D[3] = 1에서 D[3]이 가장 크므로, D[5] = D[3] + 1 즉, D[5] = 2
       
       6. i = 6, A[6] = 50 이므로, A[0] = 0, A[1] = 10, A[2] = 20, ~, A[4] = 30, A[5] = 20 뒤에 붙을 수 있음  
          D[0] = 0, ~, D[4] = 3, D[5] = 2에서 D[4]이 가장 크므로, D[6] = D[4] + 1 즉, D[4] = 4  
       
       N개의 수들에 대해 자기 자신 전의 모든 수를 다 훑으므로 'O(N²)'의 시간 복잡도를 가짐 
       ```
    - 시간 복잡도 : O(NlogN)  
  
## Reference
  - [나무위키 최장 증가 부분 수열](https://namu.wiki/w/%EC%B5%9C%EC%9E%A5%20%EC%A6%9D%EA%B0%80%20%EB%B6%80%EB%B6%84%20%EC%88%98%EC%97%B4)  
  - [Cristoval 가장 긴 증가하는 부분 수열](https://data-make.tistory.com/516)  
  - [Parkito's on the way! LIS 길이를 구하는 3가지 알고리즘](https://shoark7.github.io/programming/algorithm/3-LIS-algorithms)  
  - 프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략, 인사이트(구종만)  
***
[목차로 이동](https://github.com/youngho-j/TIL/blob/main/Algorithm/README.md "Go README.md")
